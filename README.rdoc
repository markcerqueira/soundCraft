= LOrkCraft - <em>Sonification of a Starcraft 2 Game!</em>

== RUNNING LORKCRAFT
1. Clone this repository onto your computer.
2. Run *bundle* *install* from the root of the directory to get the required gems.
3. Run *ruby* *bank_parser.rb* to start the bank parser/OSC dispatcher.
4. Run any programs that will receive OSC messages (*audio.ck* is a basic ChucK program that receives some messages)
5. Play the LOrkCraft Shipyard map from the Galaxy Editor or from Starcraft 2.

== FILES
1. *lorkCraftShipyard.SC2Map* - the Antiga Shipyard map (forced cross-spawns at the 5 and 11 o'clock positions) with the custom data-collecting triggers applied to it; for user focus the bottom-left coordinate is (0, 0) and the top-right coordinate is (108, 128). For reference, Player 1's starting location is (76.5, 9.7617) and Player 2's starting location is (31.5, 114.7578).
2. *bank_parser.rb* - Ruby script that parses the XML bank files written by our custom map and dispatches OSC messages
3. *audio.ck* - prototype audio synthesizer written in ChucK that receives OSC messages from the bank parser to produce sound 

== DATA FLOW
User data is collected as events occur (e.g. minerals collected, units die) or at fixed polling intervals (collecting APM, research progress) and written to XML bank files. Unfortunately, this is the only legitimate way to get data out of Starcraft 2, but so far the latency does not seem bad given we can control how often we poll for changes to these bank files. A Ruby script monitors the folder containing the bank files using guard/listen[https://github.com/guard/listen] and when those files are modified, the XML files are parsed using Nokogiri[http://nokogiri.org/] and OSC messages are dispatched. Any OSC listener can catch those messages and process them to display data or produce sound.

If *PRINT_DATA* is defined in *bank_parser.rb*, data for each OSC message sent will be printed out. The print statements include the address, tags, and content sent. This should be disabled for live performances, but should be useful while developing. Here is some sample output for reference:
    /lorkCraft/mineralBank.SC2Bank (ss): total_minerals_collected, 160
    /lorkCraft/mineralBank.SC2Bank (ss): current_mineral_count, 240
    /lorkCraft/unitsBuiltBank.SC2Bank (si): Nexus, 1
    /lorkCraft/unitsBuiltBank.SC2Bank (si): Probe, 8
    /lorkCraft/scoreBank.SC2Bank (ss): idle_production_time, 16
    /lorkCraft/scoreBank.SC2Bank (ss): vespene_collection_rate, 0
    /lorkCraft/scoreBank.SC2Bank (ss): enemy_structures_razed, 0
    /lorkCraft/scoreBank.SC2Bank (ss): mineral_collection_rate, 280
    /lorkCraft/scoreBank.SC2Bank (ss): resource_lost_all, 0
    /lorkCraft/scoreBank.SC2Bank (ss): total_resource_value_of_army, 0
    /lorkCraft/scoreBank.SC2Bank (ss): total_overview_score, 960
    /lorkCraft/scoreBank.SC2Bank (ss): workers_trained, 8
    /lorkCraft/scoreBank.SC2Bank (ss): cameraFocusX, 106.5
    /lorkCraft/scoreBank.SC2Bank (ss): enemy_units_killed, 0
    /lorkCraft/scoreBank.SC2Bank (ss): player_apm, 24
    /lorkCraft/scoreBank.SC2Bank (ss): cameraFocusY, 27.7617
    /lorkCraft/scoreBank.SC2Bank (ss): average_minerals_stockpiled, 44
    /lorkCraft/scoreBank.SC2Bank (ss): workers_lost, 0

== DATA COLLECTED BY MAP
* Write supply every time supply is used/made
* Write vespene collected/current count every time it changes
* Write mineral collected/current count every time it changes
* Write out messages a user types in chat
* Write out current unit/building composition when a unit/building is built or dies
* Write out coordinates where user is focused every second (this is sent as cameraFocusX, cameraFocusY in the general user info blob)
* Write general user info every second. This currently includes:
  * APM
  * Average Minerals Stockpiled 
  * Average Vespene Stockpiled
  * Mineral Collection Rate
  * Vespene Collection Rate
  * Enemy Structures Razed
  * Enemy Units Killed
  * Mineral Value of Units Lost 
  * Total Resource Value of Army
  * Workers Trained
  * Workers Lost
  * Total Overview Score
  * Supplies Used
  * ResourceLostAll
  * Idle Production Time
  * Combat Efficiency
  * X, Y coordinate of user's focus

== TODOS
* Timestamp all bank parsing and log info so a play-through can be "recreated" through the debug logs. This will be useful for testing the audio component of the system without needing to play games over and over again.
* Resilient thing that restarts the Ruby script if it fails (in case something goes wrong during the performance)
* OSC tags should more closely match the data type being sent
* Add support to the custom map to collect:
  * Write out player handle, player race
  * Every x seconds, write out current game time
  * When units are given a command, write out command (attack/move) and destination
  * When a unit/building dies write out the total units lost composition
  * Write out unit production progress status every second
  * Write out research progress status every second

== LICENSE
Copyright (c) 2013 VORGOM.COM. All rights reserved.
